{
  "id": "snapshot_1758738368474_kg17oat6g",
  "approvalId": "approval_1758738368471_hget6b0fb",
  "approvalTitle": "GitLab集成API设计文档审批",
  "version": 1,
  "timestamp": "2025-09-24T18:26:08.474Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: GitLab Integration API\n\n## 系统架构\n\n### 核心组件设计\n\n```\nGitLab Integration API\n├── Controllers\n│   ├── GitLabController (项目导入、连接管理)\n│   ├── WebhookController (Webhook事件处理)\n│   ├── ProjectSyncController (项目同步)\n│   └── MergeRequestController (MR操作)\n├── Services\n│   ├── GitLabService (GitLab API调用)\n│   ├── WebhookService (事件处理)\n│   ├── ProjectSyncService (数据同步)\n│   └── MergeRequestService (MR管理)\n├── Guards\n│   ├── GitLabTokenGuard (Token验证)\n│   └── WebhookSignatureGuard (Webhook签名验证)\n├── Interceptors\n│   ├── GitLabRateLimitInterceptor (频率限制)\n│   └── WebhookLoggingInterceptor (事件日志)\n├── Queues\n│   ├── WebhookQueue (异步事件处理)\n│   ├── SyncQueue (数据同步队列)\n│   └── RetryQueue (失败重试队列)\n└── External Services\n    ├── GitLabAPIClient (官方API客户端)\n    └── WebhookVerificationService (签名验证)\n```\n\n## 数据库设计\n\n### 表结构设计\n\n```sql\n-- GitLab连接表\nCREATE TABLE gitlab_connections (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id BIGINT NOT NULL,\n    gitlab_url VARCHAR(500) NOT NULL DEFAULT 'https://gitlab.com',\n    access_token TEXT NOT NULL,\n    refresh_token TEXT,\n    token_type VARCHAR(20) DEFAULT 'Bearer',\n    expires_at DATETIME,\n    gitlab_user_id BIGINT,\n    gitlab_username VARCHAR(100),\n    gitlab_email VARCHAR(200),\n    avatar_url VARCHAR(500),\n    connection_status ENUM('active', 'expired', 'revoked', 'error') DEFAULT 'active',\n    last_sync_at DATETIME,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    \n    INDEX idx_user_id (user_id),\n    INDEX idx_gitlab_user_id (gitlab_user_id),\n    INDEX idx_connection_status (connection_status),\n    UNIQUE KEY uk_user_gitlab (user_id, gitlab_url)\n);\n\n-- GitLab项目表\nCREATE TABLE gitlab_projects (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    project_id BIGINT NOT NULL,\n    gitlab_connection_id BIGINT NOT NULL,\n    gitlab_project_id BIGINT NOT NULL,\n    name VARCHAR(200) NOT NULL,\n    full_name VARCHAR(400) NOT NULL,\n    description TEXT,\n    default_branch VARCHAR(100) DEFAULT 'main',\n    visibility_level ENUM('private', 'internal', 'public') DEFAULT 'private',\n    ssh_url_to_repo VARCHAR(500),\n    http_url_to_repo VARCHAR(500),\n    web_url VARCHAR(500),\n    avatar_url VARCHAR(500),\n    star_count INT DEFAULT 0,\n    forks_count INT DEFAULT 0,\n    last_activity_at DATETIME,\n    created_at_gitlab DATETIME,\n    sync_status ENUM('pending', 'syncing', 'completed', 'failed') DEFAULT 'pending',\n    webhook_id BIGINT,\n    webhook_url VARCHAR(500),\n    webhook_secret VARCHAR(100),\n    webhook_status ENUM('inactive', 'active', 'failed') DEFAULT 'inactive',\n    is_archived BOOLEAN DEFAULT FALSE,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    \n    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,\n    FOREIGN KEY (gitlab_connection_id) REFERENCES gitlab_connections(id) ON DELETE CASCADE,\n    INDEX idx_project_id (project_id),\n    INDEX idx_gitlab_connection (gitlab_connection_id),\n    INDEX idx_gitlab_project_id (gitlab_project_id),\n    INDEX idx_sync_status (sync_status),\n    INDEX idx_webhook_status (webhook_status),\n    UNIQUE KEY uk_connection_gitlab_project (gitlab_connection_id, gitlab_project_id)\n);\n\n-- Webhook事件表\nCREATE TABLE webhook_events (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    gitlab_project_id BIGINT NOT NULL,\n    event_type VARCHAR(50) NOT NULL,\n    event_data JSON NOT NULL,\n    object_kind VARCHAR(50),\n    object_id BIGINT,\n    user_id BIGINT,\n    user_name VARCHAR(100),\n    project_id BIGINT,\n    source_branch VARCHAR(200),\n    target_branch VARCHAR(200),\n    merge_request_id BIGINT,\n    merge_request_iid BIGINT,\n    commit_sha VARCHAR(40),\n    processing_status ENUM('pending', 'processing', 'completed', 'failed', 'ignored') DEFAULT 'pending',\n    processing_attempts INT DEFAULT 0,\n    error_message TEXT,\n    processed_at DATETIME,\n    gitlab_created_at DATETIME,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    \n    FOREIGN KEY (gitlab_project_id) REFERENCES gitlab_projects(id) ON DELETE CASCADE,\n    INDEX idx_gitlab_project (gitlab_project_id),\n    INDEX idx_event_type (event_type),\n    INDEX idx_processing_status (processing_status),\n    INDEX idx_merge_request_id (merge_request_id),\n    INDEX idx_created_at (created_at),\n    INDEX idx_gitlab_created_at (gitlab_created_at)\n);\n\n-- MR操作记录表\nCREATE TABLE gitlab_mr_operations (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    gitlab_project_id BIGINT NOT NULL,\n    merge_request_id BIGINT NOT NULL,\n    merge_request_iid BIGINT NOT NULL,\n    operation_type ENUM('comment', 'discussion', 'approval', 'status_update') NOT NULL,\n    operation_data JSON,\n    gitlab_response JSON,\n    status ENUM('pending', 'success', 'failed') DEFAULT 'pending',\n    error_message TEXT,\n    retry_count INT DEFAULT 0,\n    created_by BIGINT,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    \n    FOREIGN KEY (gitlab_project_id) REFERENCES gitlab_projects(id) ON DELETE CASCADE,\n    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL,\n    INDEX idx_gitlab_project (gitlab_project_id),\n    INDEX idx_merge_request (merge_request_id),\n    INDEX idx_operation_type (operation_type),\n    INDEX idx_status (status),\n    INDEX idx_created_at (created_at)\n);\n```\n\n## API接口设计\n\n### Controller设计\n\n#### GitLabController\n\n```typescript\n@Controller('api/gitlab')\n@UseGuards(JwtAuthGuard)\n@UseInterceptors(GitLabRateLimitInterceptor)\nexport class GitLabController {\n  constructor(\n    private readonly gitlabService: GitLabService,\n    private readonly projectSyncService: ProjectSyncService,\n  ) {}\n\n  @Post('connect')\n  @HttpCode(HttpStatus.OK)\n  async connect(@Body() connectDto: GitLabConnectDto) {\n    return this.gitlabService.createConnection(connectDto);\n  }\n\n  @Get('connections')\n  async getConnections(@Request() req) {\n    return this.gitlabService.getUserConnections(req.user.id);\n  }\n\n  @Delete('connections/:id')\n  async deleteConnection(@Param('id') connectionId: string) {\n    return this.gitlabService.removeConnection(+connectionId);\n  }\n\n  @Get('projects/:connectionId')\n  async getProjects(\n    @Param('connectionId') connectionId: string,\n    @Query() query: GitLabProjectListDto,\n  ) {\n    return this.gitlabService.listProjects(+connectionId, query);\n  }\n\n  @Post('projects/import')\n  async importProjects(@Body() importDto: GitLabProjectImportDto) {\n    return this.projectSyncService.importProjects(importDto);\n  }\n\n  @Post('projects/:id/sync')\n  async syncProject(@Param('id') projectId: string) {\n    return this.projectSyncService.syncProject(+projectId);\n  }\n}\n```\n\n#### WebhookController\n\n```typescript\n@Controller('api/webhooks/gitlab')\n@UseInterceptors(WebhookLoggingInterceptor)\nexport class WebhookController {\n  constructor(\n    private readonly webhookService: WebhookService,\n  ) {}\n\n  @Post(':projectId')\n  @UseGuards(WebhookSignatureGuard)\n  @HttpCode(HttpStatus.OK)\n  async handleWebhook(\n    @Param('projectId') projectId: string,\n    @Headers('x-gitlab-event') eventType: string,\n    @Body() payload: any,\n  ) {\n    return this.webhookService.processEvent(+projectId, eventType, payload);\n  }\n\n  @Get('test/:projectId')\n  @UseGuards(JwtAuthGuard)\n  async testWebhook(@Param('projectId') projectId: string) {\n    return this.webhookService.testConnection(+projectId);\n  }\n}\n```\n\n### Service设计\n\n#### GitLabService\n\n```typescript\n@Injectable()\nexport class GitLabService {\n  constructor(\n    @InjectRepository(GitlabConnection)\n    private readonly connectionRepo: Repository<GitlabConnection>,\n    @InjectRepository(GitlabProject)\n    private readonly projectRepo: Repository<GitlabProject>,\n    private readonly gitlabApiClient: GitLabAPIClient,\n    private readonly redisService: RedisService,\n  ) {}\n\n  async createConnection(connectDto: GitLabConnectDto) {\n    // 验证Token有效性\n    const gitlabUser = await this.gitlabApiClient.getCurrentUser(connectDto.accessToken);\n    \n    // 创建或更新连接记录\n    const connection = await this.connectionRepo.save({\n      userId: connectDto.userId,\n      gitlabUrl: connectDto.gitlabUrl || 'https://gitlab.com',\n      accessToken: await this.encryptToken(connectDto.accessToken),\n      refreshToken: connectDto.refreshToken ? await this.encryptToken(connectDto.refreshToken) : null,\n      gitlabUserId: gitlabUser.id,\n      gitlabUsername: gitlabUser.username,\n      gitlabEmail: gitlabUser.email,\n      avatarUrl: gitlabUser.avatar_url,\n      connectionStatus: 'active',\n    });\n\n    return this.formatConnectionResponse(connection);\n  }\n\n  async listProjects(connectionId: number, query: GitLabProjectListDto) {\n    const connection = await this.getActiveConnection(connectionId);\n    const cacheKey = `gitlab:projects:${connectionId}:${JSON.stringify(query)}`;\n    \n    // 缓存检查\n    const cached = await this.redisService.get(cacheKey);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    // 调用GitLab API\n    const projects = await this.gitlabApiClient.listProjects(\n      await this.decryptToken(connection.accessToken),\n      query,\n    );\n\n    // 缓存结果（15分钟）\n    await this.redisService.setex(cacheKey, 900, JSON.stringify(projects));\n    \n    return projects;\n  }\n\n  private async encryptToken(token: string): Promise<string> {\n    const cipher = crypto.createCipher('aes-256-cbc', process.env.ENCRYPTION_KEY);\n    return cipher.update(token, 'utf8', 'hex') + cipher.final('hex');\n  }\n\n  private async decryptToken(encryptedToken: string): Promise<string> {\n    const decipher = crypto.createDecipher('aes-256-cbc', process.env.ENCRYPTION_KEY);\n    return decipher.update(encryptedToken, 'hex', 'utf8') + decipher.final('utf8');\n  }\n}\n```\n\n#### WebhookService\n\n```typescript\n@Injectable()\nexport class WebhookService {\n  constructor(\n    @InjectRepository(WebhookEvent)\n    private readonly eventRepo: Repository<WebhookEvent>,\n    @InjectQueue('webhook') private readonly webhookQueue: Queue,\n    private readonly mergeRequestService: MergeRequestService,\n  ) {}\n\n  async processEvent(projectId: number, eventType: string, payload: any) {\n    // 保存原始事件\n    const event = await this.eventRepo.save({\n      gitlabProjectId: projectId,\n      eventType,\n      eventData: payload,\n      objectKind: payload.object_kind,\n      objectId: payload.object_attributes?.id,\n      userId: payload.user?.id,\n      userName: payload.user?.name,\n      projectId: payload.project?.id,\n      sourceBranch: payload.object_attributes?.source_branch,\n      targetBranch: payload.object_attributes?.target_branch,\n      mergeRequestId: payload.object_attributes?.id,\n      mergeRequestIid: payload.object_attributes?.iid,\n      commitSha: payload.object_attributes?.last_commit?.id,\n      gitlabCreatedAt: payload.object_attributes?.created_at,\n    });\n\n    // 异步处理事件\n    await this.webhookQueue.add('process-event', {\n      eventId: event.id,\n      eventType,\n      payload,\n    }, {\n      attempts: 3,\n      backoff: {\n        type: 'exponential',\n        delay: 2000,\n      },\n    });\n\n    return { message: 'Event received', eventId: event.id };\n  }\n\n  @Process('process-event')\n  async handleEventProcessing(job: Job) {\n    const { eventId, eventType, payload } = job.data;\n    \n    try {\n      await this.eventRepo.update(eventId, {\n        processingStatus: 'processing',\n        processingAttempts: job.attemptsMade + 1,\n      });\n\n      // 根据事件类型处理\n      switch (eventType) {\n        case 'Merge Request Hook':\n          await this.handleMergeRequestEvent(payload);\n          break;\n        case 'Push Hook':\n          await this.handlePushEvent(payload);\n          break;\n        case 'Note Hook':\n          await this.handleNoteEvent(payload);\n          break;\n        default:\n          await this.eventRepo.update(eventId, { processingStatus: 'ignored' });\n          return;\n      }\n\n      await this.eventRepo.update(eventId, {\n        processingStatus: 'completed',\n        processedAt: new Date(),\n      });\n\n    } catch (error) {\n      await this.eventRepo.update(eventId, {\n        processingStatus: 'failed',\n        errorMessage: error.message,\n      });\n      throw error;\n    }\n  }\n\n  private async handleMergeRequestEvent(payload: any) {\n    const action = payload.object_attributes.action;\n    \n    if (['open', 'reopen', 'update'].includes(action)) {\n      // 触发代码审查\n      await this.mergeRequestService.triggerReview({\n        gitlabProjectId: payload.project.id,\n        mergeRequestId: payload.object_attributes.id,\n        mergeRequestIid: payload.object_attributes.iid,\n        sourceBranch: payload.object_attributes.source_branch,\n        targetBranch: payload.object_attributes.target_branch,\n        lastCommitId: payload.object_attributes.last_commit.id,\n      });\n    }\n  }\n}\n```\n\n## 安全设计\n\n### Token安全\n\n```typescript\n@Injectable()\nexport class TokenSecurityService {\n  private readonly algorithm = 'aes-256-gcm';\n  \n  async encryptToken(token: string): Promise<string> {\n    const key = crypto.scryptSync(process.env.ENCRYPTION_KEY, 'salt', 32);\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipherGCM(this.algorithm, key, iv);\n    \n    const encrypted = Buffer.concat([\n      cipher.update(token, 'utf8'),\n      cipher.final(),\n    ]);\n    \n    const authTag = cipher.getAuthTag();\n    \n    return Buffer.concat([iv, authTag, encrypted]).toString('base64');\n  }\n\n  async decryptToken(encryptedToken: string): Promise<string> {\n    const key = crypto.scryptSync(process.env.ENCRYPTION_KEY, 'salt', 32);\n    const buffer = Buffer.from(encryptedToken, 'base64');\n    \n    const iv = buffer.slice(0, 16);\n    const authTag = buffer.slice(16, 32);\n    const encrypted = buffer.slice(32);\n    \n    const decipher = crypto.createDecipherGCM(this.algorithm, key, iv);\n    decipher.setAuthTag(authTag);\n    \n    return decipher.update(encrypted, null, 'utf8') + decipher.final('utf8');\n  }\n}\n```\n\n### Webhook签名验证\n\n```typescript\n@Injectable()\nexport class WebhookSignatureGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n    const signature = request.headers['x-gitlab-token'];\n    const body = JSON.stringify(request.body);\n    \n    const projectId = request.params.projectId;\n    const expectedSignature = this.calculateSignature(body, projectId);\n    \n    return crypto.timingSafeEqual(\n      Buffer.from(signature || '', 'utf8'),\n      Buffer.from(expectedSignature, 'utf8'),\n    );\n  }\n\n  private calculateSignature(body: string, projectId: string): string {\n    const secret = process.env[`WEBHOOK_SECRET_${projectId}`] || process.env.DEFAULT_WEBHOOK_SECRET;\n    return crypto.createHmac('sha256', secret).update(body).digest('hex');\n  }\n}\n```\n\n## 性能优化\n\n### 缓存策略\n\n```typescript\n@Injectable()\nexport class GitLabCacheService {\n  constructor(private readonly redisService: RedisService) {}\n\n  // 项目信息缓存（1小时）\n  async cacheProjectInfo(connectionId: number, projects: any[]): Promise<void> {\n    const key = `gitlab:projects:${connectionId}`;\n    await this.redisService.setex(key, 3600, JSON.stringify(projects));\n  }\n\n  // 用户信息缓存（30分钟）\n  async cacheUserInfo(gitlabUserId: number, userInfo: any): Promise<void> {\n    const key = `gitlab:user:${gitlabUserId}`;\n    await this.redisService.setex(key, 1800, JSON.stringify(userInfo));\n  }\n\n  // Token有效性缓存（5分钟）\n  async cacheTokenValidation(tokenHash: string, isValid: boolean): Promise<void> {\n    const key = `gitlab:token:${tokenHash}`;\n    await this.redisService.setex(key, 300, JSON.stringify({ isValid }));\n  }\n}\n```\n\n### 频率限制\n\n```typescript\n@Injectable()\nexport class GitLabRateLimitInterceptor implements NestInterceptor {\n  constructor(private readonly redisService: RedisService) {}\n\n  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {\n    const request = context.switchToHttp().getRequest();\n    const userId = request.user?.id;\n    const key = `rate_limit:gitlab:${userId}`;\n    \n    const current = await this.redisService.incr(key);\n    if (current === 1) {\n      await this.redisService.expire(key, 60); // 1分钟窗口\n    }\n    \n    if (current > 60) { // 每分钟最多60次请求\n      throw new HttpException('Rate limit exceeded', HttpStatus.TOO_MANY_REQUESTS);\n    }\n    \n    return next.handle();\n  }\n}\n```\n\n## 错误处理\n\n### 统一错误处理\n\n```typescript\nexport enum GitLabErrorCode {\n  CONNECTION_FAILED = 'GITLAB_CONNECTION_FAILED',\n  INVALID_TOKEN = 'GITLAB_INVALID_TOKEN',\n  PROJECT_NOT_FOUND = 'GITLAB_PROJECT_NOT_FOUND',\n  WEBHOOK_VERIFICATION_FAILED = 'GITLAB_WEBHOOK_VERIFICATION_FAILED',\n  RATE_LIMIT_EXCEEDED = 'GITLAB_RATE_LIMIT_EXCEEDED',\n  SYNC_FAILED = 'GITLAB_SYNC_FAILED',\n}\n\n@Injectable()\nexport class GitLabErrorHandler {\n  handleGitLabError(error: any): never {\n    if (error.response?.status === 401) {\n      throw new BusinessException(GitLabErrorCode.INVALID_TOKEN, '访问令牌无效或已过期');\n    }\n    \n    if (error.response?.status === 404) {\n      throw new BusinessException(GitLabErrorCode.PROJECT_NOT_FOUND, '项目不存在或无权限访问');\n    }\n    \n    if (error.response?.status === 429) {\n      throw new BusinessException(GitLabErrorCode.RATE_LIMIT_EXCEEDED, 'GitLab API频率限制');\n    }\n    \n    throw new BusinessException(GitLabErrorCode.CONNECTION_FAILED, 'GitLab连接失败');\n  }\n}\n```\n\n## 监控与日志\n\n### 事件审计\n\n```typescript\n@Injectable()\nexport class GitLabAuditService {\n  constructor(\n    @InjectRepository(AuditLog)\n    private readonly auditRepo: Repository<AuditLog>,\n  ) {}\n\n  async logConnection(userId: number, action: string, details: any): Promise<void> {\n    await this.auditRepo.save({\n      userId,\n      action: `gitlab.${action}`,\n      resourceType: 'gitlab_connection',\n      details,\n      ipAddress: details.ipAddress,\n      userAgent: details.userAgent,\n    });\n  }\n\n  async logWebhookEvent(projectId: number, eventType: string, success: boolean): Promise<void> {\n    await this.auditRepo.save({\n      userId: null,\n      action: 'gitlab.webhook_received',\n      resourceType: 'webhook_event',\n      resourceId: projectId,\n      details: { eventType, success },\n    });\n  }\n}\n```\n\n### 健康检查\n\n```typescript\n@Injectable()\nexport class GitLabHealthIndicator extends HealthIndicator {\n  constructor(private readonly gitlabApiClient: GitLabAPIClient) {\n    super();\n  }\n\n  async isHealthy(key: string): Promise<HealthIndicatorResult> {\n    try {\n      await this.gitlabApiClient.checkHealth();\n      return this.getStatus(key, true);\n    } catch (error) {\n      return this.getStatus(key, false, { message: error.message });\n    }\n  }\n}\n```\n\n## 配置管理\n\n### 环境配置\n\n```typescript\nexport interface GitLabConfig {\n  defaultUrl: string;\n  apiVersion: string;\n  timeout: number;\n  retryAttempts: number;\n  rateLimitPerMinute: number;\n  cacheTtl: {\n    projects: number;\n    users: number;\n    tokens: number;\n  };\n  webhook: {\n    secret: string;\n    maxRetries: number;\n    retryDelay: number;\n  };\n}\n\n@Injectable()\nexport class GitLabConfigService {\n  private readonly config: GitLabConfig = {\n    defaultUrl: process.env.GITLAB_DEFAULT_URL || 'https://gitlab.com',\n    apiVersion: process.env.GITLAB_API_VERSION || 'v4',\n    timeout: +process.env.GITLAB_TIMEOUT || 10000,\n    retryAttempts: +process.env.GITLAB_RETRY_ATTEMPTS || 3,\n    rateLimitPerMinute: +process.env.GITLAB_RATE_LIMIT || 60,\n    cacheTtl: {\n      projects: +process.env.GITLAB_CACHE_PROJECTS || 3600,\n      users: +process.env.GITLAB_CACHE_USERS || 1800,\n      tokens: +process.env.GITLAB_CACHE_TOKENS || 300,\n    },\n    webhook: {\n      secret: process.env.GITLAB_WEBHOOK_SECRET,\n      maxRetries: +process.env.GITLAB_WEBHOOK_MAX_RETRIES || 3,\n      retryDelay: +process.env.GITLAB_WEBHOOK_RETRY_DELAY || 2000,\n    },\n  };\n\n  get(): GitLabConfig {\n    return this.config;\n  }\n}\n```\n\n## 测试策略\n\n### 单元测试覆盖\n\n- GitLabService: Token加密/解密、API调用、错误处理\n- WebhookService: 事件处理逻辑、签名验证、异步队列\n- ProjectSyncService: 数据同步、冲突解决、状态管理\n- Guards: 认证、授权、签名验证\n- Interceptors: 频率限制、日志记录、错误拦截\n\n### 集成测试\n\n- GitLab API连接测试\n- Webhook端到端测试\n- 数据库事务测试\n- 缓存功能测试\n- 队列处理测试\n\n## 部署注意事项\n\n1. **环境变量配置**: 确保所有敏感配置通过环境变量传入\n2. **数据库迁移**: 使用Prisma迁移管理数据库结构变更\n3. **Redis配置**: 配置Redis用于缓存和队列处理\n4. **Webhook URL**: 确保Webhook URL可被GitLab访问\n5. **SSL证书**: 生产环境必须使用HTTPS\n6. **监控设置**: 配置日志收集和性能监控\n7. **备份策略**: 定期备份数据库和配置文件",
  "fileStats": {
    "size": 21505,
    "lines": 701,
    "lastModified": "2025-09-24T18:09:32.174Z"
  },
  "comments": []
}