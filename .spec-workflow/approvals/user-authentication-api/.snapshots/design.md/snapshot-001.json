{
  "id": "snapshot_1758738358708_j8gjsfp9u",
  "approvalId": "approval_1758738358705_2j71679o9",
  "approvalTitle": "用户认证API设计文档审批",
  "version": 1,
  "timestamp": "2025-09-24T18:25:58.708Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: User Authentication API System\n\n## Overview\n用户认证 API 系统设计采用分层架构模式，基于 NestJS 框架构建，提供安全、可扩展的身份验证和授权服务。系统支持多种认证方式，包括传统邮箱密码登录、GitLab OAuth 集成，以及完整的用户生命周期管理。\n\n## System Architecture\n\n### High-Level Architecture\n```mermaid\ngraph TB\n    subgraph \"Client Layer\"\n        WEB[Web Frontend]\n        MOB[Mobile App]\n        API_CLIENT[API Client]\n    end\n    \n    subgraph \"API Gateway\"\n        GW[NestJS Gateway]\n        AUTH_MIDDLEWARE[Auth Middleware]\n        RATE_LIMITER[Rate Limiter]\n    end\n    \n    subgraph \"Authentication Service\"\n        AUTH_CONTROLLER[Auth Controller]\n        USER_CONTROLLER[User Controller]\n        AUTH_SERVICE[Auth Service]\n        USER_SERVICE[User Service]\n        JWT_SERVICE[JWT Service]\n        OAUTH_SERVICE[OAuth Service]\n    end\n    \n    subgraph \"Data Layer\"\n        REDIS[(Redis Cache)]\n        DB[(MySQL Database)]\n    end\n    \n    subgraph \"External Services\"\n        GITLAB[GitLab OAuth]\n        EMAIL[Email Service]\n    end\n    \n    WEB --> GW\n    MOB --> GW\n    API_CLIENT --> GW\n    \n    GW --> AUTH_MIDDLEWARE\n    AUTH_MIDDLEWARE --> RATE_LIMITER\n    RATE_LIMITER --> AUTH_CONTROLLER\n    RATE_LIMITER --> USER_CONTROLLER\n    \n    AUTH_CONTROLLER --> AUTH_SERVICE\n    USER_CONTROLLER --> USER_SERVICE\n    AUTH_SERVICE --> JWT_SERVICE\n    AUTH_SERVICE --> OAUTH_SERVICE\n    \n    AUTH_SERVICE --> REDIS\n    AUTH_SERVICE --> DB\n    USER_SERVICE --> DB\n    \n    OAUTH_SERVICE --> GITLAB\n    AUTH_SERVICE --> EMAIL\n```\n\n### Component Architecture\n\n#### 1. Controller Layer\n```typescript\n// Auth Controller - 处理认证相关请求\n@Controller('auth')\n@ApiTags('Authentication')\nexport class AuthController {\n  @Post('register')\n  @ApiOperation({ summary: '用户注册' })\n  register(@Body() registerDto: RegisterDto): Promise<AuthResponse>\n  \n  @Post('login')\n  @ApiOperation({ summary: '用户登录' })\n  login(@Body() loginDto: LoginDto): Promise<AuthResponse>\n  \n  @Post('refresh')\n  @ApiOperation({ summary: 'Token刷新' })\n  refreshToken(@Body() refreshDto: RefreshTokenDto): Promise<TokenResponse>\n  \n  @Post('logout')\n  @UseGuards(JwtAuthGuard)\n  @ApiOperation({ summary: '用户登出' })\n  logout(@GetUser() user: User): Promise<MessageResponse>\n  \n  @Get('gitlab/url')\n  @ApiOperation({ summary: '获取GitLab OAuth URL' })\n  getGitlabAuthUrl(): Promise<OAuthUrlResponse>\n  \n  @Post('gitlab/callback')\n  @ApiOperation({ summary: 'GitLab OAuth回调' })\n  gitlabCallback(@Body() callbackDto: OAuthCallbackDto): Promise<AuthResponse>\n}\n\n// User Controller - 处理用户管理请求  \n@Controller('users')\n@ApiTags('User Management')\n@UseGuards(JwtAuthGuard)\nexport class UserController {\n  @Get('profile')\n  @ApiOperation({ summary: '获取用户资料' })\n  getProfile(@GetUser() user: User): Promise<UserProfile>\n  \n  @Put('profile')\n  @ApiOperation({ summary: '更新用户资料' })\n  updateProfile(@GetUser() user: User, @Body() updateDto: UpdateProfileDto): Promise<UserProfile>\n  \n  @Post('change-password')\n  @ApiOperation({ summary: '修改密码' })\n  changePassword(@GetUser() user: User, @Body() changePasswordDto: ChangePasswordDto): Promise<MessageResponse>\n}\n```\n\n#### 2. Service Layer\n```typescript\n// Auth Service - 核心认证业务逻辑\n@Injectable()\nexport class AuthService {\n  constructor(\n    private userService: UserService,\n    private jwtService: JwtService,\n    private redisService: RedisService,\n    private gitlabOAuthService: GitlabOAuthService,\n    private emailService: EmailService,\n  ) {}\n  \n  // 用户注册\n  async register(registerDto: RegisterDto): Promise<AuthResponse> {\n    // 1. 验证邮箱唯一性\n    // 2. 密码强度验证\n    // 3. 密码加密存储\n    // 4. 创建用户记录\n    // 5. 生成 JWT Token\n    // 6. 返回认证信息\n  }\n  \n  // 用户登录\n  async login(loginDto: LoginDto): Promise<AuthResponse> {\n    // 1. 验证用户凭据\n    // 2. 检查账户状态\n    // 3. 登录失败计数管理\n    // 4. 生成 JWT Token\n    // 5. 记录登录历史\n    // 6. 返回认证信息\n  }\n  \n  // GitLab OAuth登录\n  async gitlabLogin(code: string, state: string): Promise<AuthResponse> {\n    // 1. 验证 OAuth state\n    // 2. 交换 access token\n    // 3. 获取 GitLab 用户信息\n    // 4. 创建或更新本地用户\n    // 5. 生成系统 JWT Token\n    // 6. 返回认证信息\n  }\n}\n\n// JWT Service - Token管理服务\n@Injectable()\nexport class JwtService {\n  // 生成访问令牌\n  async generateAccessToken(user: User): Promise<string>\n  \n  // 生成刷新令牌\n  async generateRefreshToken(user: User): Promise<string>\n  \n  // 验证令牌\n  async verifyToken(token: string): Promise<JwtPayload>\n  \n  // 刷新令牌\n  async refreshToken(refreshToken: string): Promise<TokenResponse>\n  \n  // 注销令牌（加入黑名单）\n  async revokeToken(token: string): Promise<void>\n}\n```\n\n#### 3. Data Layer\n```typescript\n// User Entity - 用户数据模型\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n  \n  @Column({ unique: true })\n  username: string;\n  \n  @Column({ unique: true })\n  email: string;\n  \n  @Column()\n  password: string;\n  \n  @Column({ nullable: true })\n  fullName: string;\n  \n  @Column({ nullable: true })\n  avatar: string;\n  \n  @Column({ default: true })\n  isActive: boolean;\n  \n  @Column({ nullable: true })\n  gitlabUserId: string;\n  \n  @Column({ type: 'text', nullable: true })\n  gitlabAccessToken: string;\n  \n  @Column({ type: 'json', nullable: true })\n  preferences: Record<string, any>;\n  \n  @Column({ default: 0 })\n  failedLoginAttempts: number;\n  \n  @Column({ nullable: true })\n  lockedUntil: Date;\n  \n  @Column({ nullable: true })\n  emailVerifiedAt: Date;\n  \n  @CreateDateColumn()\n  createdAt: Date;\n  \n  @UpdateDateColumn()\n  updatedAt: Date;\n  \n  // Relations\n  @OneToMany(() => Project, project => project.owner)\n  projects: Project[];\n  \n  @OneToMany(() => Review, review => review.requestedBy)\n  reviews: Review[];\n  \n  @OneToMany(() => LoginHistory, history => history.user)\n  loginHistory: LoginHistory[];\n}\n\n// Token Blacklist Entity - Token黑名单\n@Entity('token_blacklist')\nexport class TokenBlacklist {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n  \n  @Column()\n  tokenHash: string;\n  \n  @ManyToOne(() => User)\n  user: User;\n  \n  @Column()\n  expiresAt: Date;\n  \n  @CreateDateColumn()\n  createdAt: Date;\n}\n\n// Login History Entity - 登录历史\n@Entity('login_history')\nexport class LoginHistory {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n  \n  @ManyToOne(() => User, user => user.loginHistory)\n  user: User;\n  \n  @Column({ nullable: true })\n  ipAddress: string;\n  \n  @Column({ type: 'text', nullable: true })\n  userAgent: string;\n  \n  @Column()\n  loginMethod: 'email' | 'gitlab';\n  \n  @Column()\n  success: boolean;\n  \n  @Column({ nullable: true })\n  failureReason: string;\n  \n  @CreateDateColumn()\n  createdAt: Date;\n}\n```\n\n## Security Design\n\n### Authentication Flow\n```mermaid\nsequenceDiagram\n    participant Client\n    participant API\n    participant AuthService\n    participant Database\n    participant Redis\n    \n    Note over Client,Redis: 用户登录流程\n    Client->>API: POST /auth/login {email, password}\n    API->>AuthService: validateCredentials(email, password)\n    AuthService->>Database: findUserByEmail(email)\n    Database-->>AuthService: user data\n    AuthService->>AuthService: comparePassword(password, hashedPassword)\n    \n    alt 登录成功\n        AuthService->>AuthService: generateTokens(user)\n        AuthService->>Redis: storeRefreshToken(userId, refreshToken)\n        AuthService-->>API: {accessToken, refreshToken, user}\n        API-->>Client: 200 OK {tokens, user}\n        \n        Note over AuthService: 记录登录历史\n        AuthService->>Database: createLoginHistory(user, success=true)\n    else 登录失败\n        AuthService->>Database: incrementFailedAttempts(userId)\n        AuthService-->>API: Invalid credentials\n        API-->>Client: 401 Unauthorized\n        \n        Note over AuthService: 记录失败历史\n        AuthService->>Database: createLoginHistory(user, success=false)\n    end\n```\n\n### JWT Token Structure\n```typescript\n// Access Token Payload\ninterface AccessTokenPayload {\n  sub: string;           // 用户ID\n  email: string;         // 用户邮箱\n  username: string;      // 用户名\n  roles: string[];       // 用户角色\n  iat: number;          // 签发时间\n  exp: number;          // 过期时间\n}\n\n// Refresh Token Payload\ninterface RefreshTokenPayload {\n  sub: string;           // 用户ID\n  tokenId: string;       // Token唯一标识\n  iat: number;          // 签发时间\n  exp: number;          // 过期时间\n}\n```\n\n### Password Security\n```typescript\n// 密码加密策略\n@Injectable()\nexport class PasswordService {\n  private readonly saltRounds = 10;\n  \n  async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, this.saltRounds);\n  }\n  \n  async comparePassword(password: string, hashedPassword: string): Promise<boolean> {\n    return bcrypt.compare(password, hashedPassword);\n  }\n  \n  validatePasswordStrength(password: string): PasswordValidation {\n    const requirements = {\n      minLength: 8,\n      requireUppercase: true,\n      requireLowercase: true,\n      requireNumbers: true,\n      requireSpecialChars: false,\n    };\n    \n    return {\n      isValid: this.checkAllRequirements(password, requirements),\n      requirements,\n      strength: this.calculateStrength(password),\n    };\n  }\n}\n```\n\n### OAuth Integration\n```typescript\n// GitLab OAuth Service\n@Injectable()\nexport class GitlabOAuthService {\n  constructor(private httpService: HttpService) {}\n  \n  // 生成授权URL\n  generateAuthUrl(state: string): string {\n    const params = new URLSearchParams({\n      client_id: this.configService.get('GITLAB_CLIENT_ID'),\n      redirect_uri: this.configService.get('GITLAB_REDIRECT_URI'),\n      response_type: 'code',\n      scope: 'read_user read_api',\n      state,\n    });\n    \n    return `https://gitlab.com/oauth/authorize?${params.toString()}`;\n  }\n  \n  // 交换访问令牌\n  async exchangeCodeForToken(code: string): Promise<OAuthTokenResponse> {\n    const response = await this.httpService.post('https://gitlab.com/oauth/token', {\n      client_id: this.configService.get('GITLAB_CLIENT_ID'),\n      client_secret: this.configService.get('GITLAB_CLIENT_SECRET'),\n      code,\n      grant_type: 'authorization_code',\n      redirect_uri: this.configService.get('GITLAB_REDIRECT_URI'),\n    }).toPromise();\n    \n    return response.data;\n  }\n  \n  // 获取用户信息\n  async getUserInfo(accessToken: string): Promise<GitlabUser> {\n    const response = await this.httpService.get('https://gitlab.com/api/v4/user', {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    }).toPromise();\n    \n    return response.data;\n  }\n}\n```\n\n## API Design\n\n### Request/Response DTOs\n```typescript\n// 注册请求DTO\nexport class RegisterDto {\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n  \n  @ApiProperty({ example: 'SecureP@ss123' })\n  @IsStrongPassword()\n  @MinLength(8)\n  password: string;\n  \n  @ApiProperty({ example: 'johndoe' })\n  @IsString()\n  @MinLength(3)\n  @MaxLength(50)\n  username: string;\n  \n  @ApiProperty({ example: 'John Doe', required: false })\n  @IsOptional()\n  @IsString()\n  fullName?: string;\n}\n\n// 登录请求DTO\nexport class LoginDto {\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n  \n  @ApiProperty({ example: 'SecureP@ss123' })\n  @IsString()\n  password: string;\n  \n  @ApiProperty({ example: false, required: false })\n  @IsOptional()\n  @IsBoolean()\n  rememberMe?: boolean;\n}\n\n// 认证响应DTO\nexport class AuthResponse {\n  @ApiProperty()\n  user: UserProfile;\n  \n  @ApiProperty()\n  tokens: TokenResponse;\n  \n  @ApiProperty()\n  expiresIn: number;\n}\n\nexport class TokenResponse {\n  @ApiProperty()\n  accessToken: string;\n  \n  @ApiProperty()\n  refreshToken: string;\n  \n  @ApiProperty()\n  tokenType: string = 'Bearer';\n}\n\nexport class UserProfile {\n  @ApiProperty()\n  id: string;\n  \n  @ApiProperty()\n  username: string;\n  \n  @ApiProperty()\n  email: string;\n  \n  @ApiProperty()\n  fullName: string;\n  \n  @ApiProperty()\n  avatar: string;\n  \n  @ApiProperty()\n  isActive: boolean;\n  \n  @ApiProperty()\n  gitlabUserId?: string;\n  \n  @ApiProperty()\n  createdAt: Date;\n  \n  @ApiProperty()\n  lastLoginAt?: Date;\n}\n```\n\n### API Endpoints Documentation\n\n#### Authentication Endpoints\n```typescript\n/**\n * POST /api/auth/register\n * 用户注册\n */\n@Post('register')\n@ApiOperation({\n  summary: '用户注册',\n  description: '使用邮箱和密码创建新用户账号',\n})\n@ApiResponse({\n  status: 201,\n  description: '注册成功',\n  type: AuthResponse,\n})\n@ApiResponse({\n  status: 400,\n  description: '请求参数错误或邮箱已存在',\n})\n@ApiResponse({\n  status: 429,\n  description: '请求频率超限',\n})\nregister(@Body() registerDto: RegisterDto): Promise<AuthResponse>\n\n/**\n * POST /api/auth/login\n * 用户登录\n */\n@Post('login')\n@ApiOperation({\n  summary: '用户登录',\n  description: '使用邮箱和密码进行身份验证',\n})\n@ApiResponse({\n  status: 200,\n  description: '登录成功',\n  type: AuthResponse,\n})\n@ApiResponse({\n  status: 401,\n  description: '凭据无效或账户被锁定',\n})\n@ApiResponse({\n  status: 429,\n  description: '登录尝试过于频繁',\n})\nlogin(@Body() loginDto: LoginDto): Promise<AuthResponse>\n```\n\n## Error Handling Design\n\n### Error Response Structure\n```typescript\n// 标准错误响应\nexport class ErrorResponse {\n  @ApiProperty()\n  error: {\n    code: string;\n    message: string;\n    details?: string;\n    timestamp: string;\n    path: string;\n    traceId?: string;\n  };\n}\n\n// 验证错误响应\nexport class ValidationErrorResponse extends ErrorResponse {\n  @ApiProperty()\n  error: {\n    code: 'VALIDATION_ERROR';\n    message: string;\n    details: string;\n    fields: {\n      [key: string]: string[];\n    };\n    timestamp: string;\n    path: string;\n  };\n}\n```\n\n### Error Codes\n```typescript\nexport enum AuthErrorCodes {\n  // 认证错误\n  INVALID_CREDENTIALS = 'AUTH_001',\n  ACCOUNT_LOCKED = 'AUTH_002',\n  TOKEN_EXPIRED = 'AUTH_003',\n  TOKEN_INVALID = 'AUTH_004',\n  \n  // 注册错误\n  EMAIL_EXISTS = 'AUTH_005',\n  WEAK_PASSWORD = 'AUTH_006',\n  INVALID_USERNAME = 'AUTH_007',\n  \n  // OAuth错误\n  OAUTH_AUTHORIZATION_FAILED = 'OAUTH_001',\n  OAUTH_TOKEN_INVALID = 'OAUTH_002',\n  OAUTH_USER_INFO_FAILED = 'OAUTH_003',\n  \n  // 系统错误\n  INTERNAL_ERROR = 'SYS_001',\n  RATE_LIMIT_EXCEEDED = 'SYS_002',\n  SERVICE_UNAVAILABLE = 'SYS_003',\n}\n```\n\n### Global Exception Filter\n```typescript\n@Catch()\nexport class GlobalExceptionFilter implements ExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    \n    let status: number;\n    let errorCode: string;\n    let message: string;\n    let details: string;\n    \n    if (exception instanceof HttpException) {\n      status = exception.getStatus();\n      const errorResponse = exception.getResponse();\n      \n      if (typeof errorResponse === 'object' && errorResponse !== null) {\n        errorCode = (errorResponse as any).code || 'HTTP_ERROR';\n        message = (errorResponse as any).message || exception.message;\n        details = (errorResponse as any).details;\n      } else {\n        errorCode = 'HTTP_ERROR';\n        message = errorResponse as string;\n      }\n    } else {\n      status = 500;\n      errorCode = 'INTERNAL_ERROR';\n      message = 'Internal server error';\n      details = process.env.NODE_ENV === 'development' ? (exception as Error).stack : undefined;\n    }\n    \n    const errorResponse = {\n      error: {\n        code: errorCode,\n        message,\n        details,\n        timestamp: new Date().toISOString(),\n        path: request.url,\n        traceId: request.headers['x-trace-id'],\n      },\n    };\n    \n    response.status(status).json(errorResponse);\n  }\n}\n```\n\n## Validation and Guards\n\n### Authentication Guards\n```typescript\n// JWT认证守卫\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n  \n  handleRequest(err: any, user: any, info: any) {\n    if (err || !user) {\n      throw err || new UnauthorizedException('Invalid token');\n    }\n    return user;\n  }\n}\n\n// 角色权限守卫\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n  \n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>('roles', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    \n    if (!requiredRoles) {\n      return true;\n    }\n    \n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some((role) => user.roles?.includes(role));\n  }\n}\n\n// 频率限制守卫\n@Injectable()\nexport class ThrottlerGuard extends ThrottlerGuard {\n  protected async getTracker(req: Record<string, any>): Promise<string> {\n    return req.ips.length ? req.ips[0] : req.ip; // 使用IP作为跟踪标识\n  }\n}\n```\n\n### Validation Pipes\n```typescript\n// 自定义验证管道\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    \n    const object = plainToClass(metatype, value);\n    const errors = await validate(object);\n    \n    if (errors.length > 0) {\n      const messages = this.buildErrorMessages(errors);\n      throw new BadRequestException({\n        code: 'VALIDATION_ERROR',\n        message: 'Validation failed',\n        fields: messages,\n      });\n    }\n    \n    return object;\n  }\n  \n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n  \n  private buildErrorMessages(errors: ValidationError[]): Record<string, string[]> {\n    const messages: Record<string, string[]> = {};\n    \n    errors.forEach((error) => {\n      messages[error.property] = Object.values(error.constraints || {});\n    });\n    \n    return messages;\n  }\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n```typescript\ndescribe('AuthService', () => {\n  let service: AuthService;\n  let userService: UserService;\n  let jwtService: JwtService;\n  let redisService: RedisService;\n  \n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        AuthService,\n        {\n          provide: UserService,\n          useValue: mockUserService,\n        },\n        {\n          provide: JwtService,\n          useValue: mockJwtService,\n        },\n        {\n          provide: RedisService,\n          useValue: mockRedisService,\n        },\n      ],\n    }).compile();\n    \n    service = module.get<AuthService>(AuthService);\n  });\n  \n  describe('register', () => {\n    it('应该成功注册新用户', async () => {\n      // 测试用户注册逻辑\n    });\n    \n    it('应该在邮箱已存在时抛出错误', async () => {\n      // 测试邮箱唯一性验证\n    });\n    \n    it('应该在密码不符合要求时抛出错误', async () => {\n      // 测试密码强度验证\n    });\n  });\n  \n  describe('login', () => {\n    it('应该使用有效凭据成功登录', async () => {\n      // 测试正常登录流程\n    });\n    \n    it('应该在无效凭据时抛出错误', async () => {\n      // 测试登录失败处理\n    });\n    \n    it('应该在账户锁定时抛出错误', async () => {\n      // 测试账户锁定机制\n    });\n  });\n});\n```\n\n### Integration Tests\n```typescript\ndescribe('AuthController (e2e)', () => {\n  let app: INestApplication;\n  \n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n    \n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n  \n  it('/auth/register (POST)', () => {\n    return request(app.getHttpServer())\n      .post('/auth/register')\n      .send({\n        email: 'test@example.com',\n        password: 'SecureP@ss123',\n        username: 'testuser',\n      })\n      .expect(201)\n      .expect((res) => {\n        expect(res.body.user).toBeDefined();\n        expect(res.body.tokens).toBeDefined();\n        expect(res.body.tokens.accessToken).toBeDefined();\n        expect(res.body.tokens.refreshToken).toBeDefined();\n      });\n  });\n  \n  it('/auth/login (POST)', () => {\n    return request(app.getHttpServer())\n      .post('/auth/login')\n      .send({\n        email: 'test@example.com',\n        password: 'SecureP@ss123',\n      })\n      .expect(200)\n      .expect((res) => {\n        expect(res.body.user).toBeDefined();\n        expect(res.body.tokens).toBeDefined();\n      });\n  });\n});\n```\n\n## Performance Considerations\n\n### Caching Strategy\n```typescript\n// Redis缓存配置\n@Injectable()\nexport class CacheService {\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}\n  \n  // 缓存用户信息（短期）\n  async cacheUser(userId: string, user: User, ttl = 300): Promise<void> {\n    await this.cacheManager.set(`user:${userId}`, user, { ttl });\n  }\n  \n  // 缓存刷新令牌（长期）\n  async cacheRefreshToken(userId: string, token: string, ttl = 2592000): Promise<void> {\n    await this.cacheManager.set(`refresh:${userId}`, token, { ttl });\n  }\n  \n  // 缓存登录失败次数\n  async cacheFailedAttempts(email: string, attempts: number, ttl = 900): Promise<void> {\n    await this.cacheManager.set(`failed:${email}`, attempts, { ttl });\n  }\n}\n```\n\n### Database Optimization\n```sql\n-- 用户表索引优化\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_username ON users(username);\nCREATE INDEX idx_users_gitlab_user_id ON users(gitlab_user_id);\nCREATE INDEX idx_users_is_active ON users(is_active);\n\n-- 登录历史表索引优化\nCREATE INDEX idx_login_history_user_id ON login_history(user_id);\nCREATE INDEX idx_login_history_created_at ON login_history(created_at);\nCREATE INDEX idx_login_history_success ON login_history(success);\n\n-- Token黑名单表索引优化\nCREATE INDEX idx_token_blacklist_token_hash ON token_blacklist(token_hash);\nCREATE INDEX idx_token_blacklist_expires_at ON token_blacklist(expires_at);\n```\n\n## Deployment Configuration\n\n### Environment Configuration\n```typescript\n// 配置验证Schema\nexport const configValidationSchema = Joi.object({\n  // 数据库配置\n  DATABASE_URL: Joi.string().required(),\n  DATABASE_SSL: Joi.boolean().default(false),\n  \n  // Redis配置\n  REDIS_HOST: Joi.string().default('localhost'),\n  REDIS_PORT: Joi.number().default(6379),\n  REDIS_PASSWORD: Joi.string().optional(),\n  \n  // JWT配置\n  JWT_SECRET: Joi.string().required().min(32),\n  JWT_EXPIRES_IN: Joi.string().default('15m'),\n  JWT_REFRESH_EXPIRES_IN: Joi.string().default('30d'),\n  \n  // GitLab OAuth配置\n  GITLAB_CLIENT_ID: Joi.string().required(),\n  GITLAB_CLIENT_SECRET: Joi.string().required(),\n  GITLAB_REDIRECT_URI: Joi.string().uri().required(),\n  \n  // 邮件服务配置\n  SMTP_HOST: Joi.string().required(),\n  SMTP_PORT: Joi.number().default(587),\n  SMTP_USER: Joi.string().required(),\n  SMTP_PASS: Joi.string().required(),\n  \n  // 安全配置\n  RATE_LIMIT_TTL: Joi.number().default(60),\n  RATE_LIMIT_MAX: Joi.number().default(100),\n  BCRYPT_ROUNDS: Joi.number().default(10),\n  \n  // 应用配置\n  NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),\n  PORT: Joi.number().default(3000),\n  API_PREFIX: Joi.string().default('api'),\n});\n```\n\n### Module Configuration\n```typescript\n@Module({\n  imports: [\n    // 配置模块\n    ConfigModule.forRoot({\n      isGlobal: true,\n      validationSchema: configValidationSchema,\n    }),\n    \n    // 数据库模块\n    TypeOrmModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        type: 'mysql',\n        url: configService.get('DATABASE_URL'),\n        ssl: configService.get('DATABASE_SSL'),\n        entities: [User, TokenBlacklist, LoginHistory],\n        synchronize: configService.get('NODE_ENV') !== 'production',\n        logging: configService.get('NODE_ENV') === 'development',\n      }),\n      inject: [ConfigService],\n    }),\n    \n    // Redis缓存模块\n    CacheModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        store: redisStore,\n        host: configService.get('REDIS_HOST'),\n        port: configService.get('REDIS_PORT'),\n        password: configService.get('REDIS_PASSWORD'),\n        ttl: 300, // 默认缓存5分钟\n      }),\n      inject: [ConfigService],\n    }),\n    \n    // JWT模块\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        secret: configService.get('JWT_SECRET'),\n        signOptions: {\n          expiresIn: configService.get('JWT_EXPIRES_IN'),\n        },\n      }),\n      inject: [ConfigService],\n    }),\n    \n    // 频率限制模块\n    ThrottlerModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        ttl: configService.get('RATE_LIMIT_TTL'),\n        limit: configService.get('RATE_LIMIT_MAX'),\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  controllers: [AuthController, UserController],\n  providers: [\n    AuthService,\n    UserService,\n    JwtService,\n    GitlabOAuthService,\n    PasswordService,\n    CacheService,\n    // 全局守卫\n    {\n      provide: APP_GUARD,\n      useClass: ThrottlerGuard,\n    },\n    // 全局异常过滤器\n    {\n      provide: APP_FILTER,\n      useClass: GlobalExceptionFilter,\n    },\n    // 全局验证管道\n    {\n      provide: APP_PIPE,\n      useClass: ValidationPipe,\n    },\n  ],\n  exports: [AuthService, UserService, JwtService],\n})\nexport class AuthModule {}\n```\n\n## Documentation and API Specs\n\n### OpenAPI Configuration\n```typescript\n// Swagger配置\nexport function setupSwagger(app: INestApplication) {\n  const config = new DocumentBuilder()\n    .setTitle('MoonLens Authentication API')\n    .setDescription('用户认证和授权API文档')\n    .setVersion('1.0')\n    .addBearerAuth(\n      {\n        type: 'http',\n        scheme: 'bearer',\n        bearerFormat: 'JWT',\n        name: 'JWT',\n        description: 'Enter JWT token',\n        in: 'header',\n      },\n      'JWT-auth',\n    )\n    .addServer('http://localhost:3000', 'Development server')\n    .addServer('https://api.moonlens.dev', 'Production server')\n    .build();\n    \n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document, {\n    swaggerOptions: {\n      persistAuthorization: true,\n    },\n  });\n}\n```\n\n## Next Steps\n\n设计文档完成后，下一步将创建详细的实施任务清单，包括：\n\n1. **环境搭建任务**: 数据库迁移、Redis配置、环境变量设置\n2. **核心服务开发**: 认证服务、用户服务、JWT服务实现\n3. **API控制器开发**: 路由定义、请求验证、响应格式化\n4. **安全机制实现**: 认证守卫、权限控制、频率限制\n5. **OAuth集成开发**: GitLab集成、回调处理、用户信息同步\n6. **测试用例编写**: 单元测试、集成测试、端到端测试\n7. **文档完善**: API文档、部署指南、维护手册\n\n这个设计提供了完整的用户认证API系统架构蓝图，确保系统的安全性、可扩展性和维护性。",
  "fileStats": {
    "size": 27721,
    "lines": 1101,
    "lastModified": "2025-09-24T18:04:47.734Z"
  },
  "comments": []
}