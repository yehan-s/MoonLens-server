{
  "id": "snapshot_1758738363460_3qqxri88i",
  "approvalId": "approval_1758738363448_f6ufqd5o4",
  "approvalTitle": "项目管理API设计文档审批",
  "version": 1,
  "timestamp": "2025-09-24T18:26:03.460Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Project Management API System\n\n## Overview\n项目管理 API 系统负责处理 MoonLens 平台中的项目生命周期管理，包括项目 CRUD 操作、成员权限管理、配置管理和数据统计分析。采用分层架构设计，确保系统的可扩展性和维护性。\n\n## System Architecture\n\n### High-Level Architecture\n```mermaid\ngraph TB\n    subgraph \"API Layer\"\n        PC[Projects Controller]\n        MC[Members Controller]\n        CC[Config Controller]\n        SC[Statistics Controller]\n    end\n    \n    subgraph \"Service Layer\"\n        PS[Projects Service]\n        MS[Members Service]\n        CS[Config Service]\n        STS[Statistics Service]\n        PS_PERM[Permission Service]\n    end\n    \n    subgraph \"Data Layer\"\n        DB[(MySQL Database)]\n        REDIS[(Redis Cache)]\n    end\n    \n    subgraph \"External Dependencies\"\n        GITLAB[GitLab API]\n        QUEUE[Task Queue]\n    end\n    \n    PC --> PS\n    MC --> MS\n    CC --> CS\n    SC --> STS\n    \n    PS --> PS_PERM\n    MS --> PS_PERM\n    \n    PS --> DB\n    PS --> REDIS\n    MS --> DB\n    CS --> DB\n    STS --> DB\n    \n    PS --> GITLAB\n    PS --> QUEUE\n```\n\n## Component Design\n\n### 1. Controller Layer\n```typescript\n@Controller('projects')\n@ApiTags('Project Management')\n@UseGuards(JwtAuthGuard)\nexport class ProjectsController {\n  @Post()\n  @RequiredPermissions('project:create')\n  @ApiOperation({ summary: '创建项目' })\n  createProject(@Body() createDto: CreateProjectDto, @GetUser() user: User): Promise<ProjectResponse>\n  \n  @Get()\n  @ApiOperation({ summary: '获取项目列表' })\n  getProjects(@Query() queryDto: ProjectQueryDto, @GetUser() user: User): Promise<ProjectListResponse>\n  \n  @Get(':id')\n  @RequiredPermissions('project:read')\n  @ApiOperation({ summary: '获取项目详情' })\n  getProject(@Param('id') id: string): Promise<ProjectDetailResponse>\n  \n  @Put(':id')\n  @RequiredPermissions('project:update')\n  @ApiOperation({ summary: '更新项目' })\n  updateProject(@Param('id') id: string, @Body() updateDto: UpdateProjectDto): Promise<ProjectResponse>\n  \n  @Delete(':id')\n  @RequiredPermissions('project:delete')\n  @ApiOperation({ summary: '删除项目' })\n  deleteProject(@Param('id') id: string): Promise<MessageResponse>\n}\n\n@Controller('projects/:projectId/members')\n@ApiTags('Project Members')\n@UseGuards(JwtAuthGuard, ProjectAccessGuard)\nexport class ProjectMembersController {\n  @Get()\n  @RequiredPermissions('project:members:read')\n  getMembers(@Param('projectId') projectId: string): Promise<MemberListResponse>\n  \n  @Post()\n  @RequiredPermissions('project:members:create')\n  addMembers(@Param('projectId') projectId: string, @Body() addDto: AddMembersDto): Promise<MemberBatchResponse>\n  \n  @Put(':memberId')\n  @RequiredPermissions('project:members:update')\n  updateMemberRole(@Param('projectId') projectId: string, @Param('memberId') memberId: string, @Body() updateDto: UpdateMemberRoleDto): Promise<MemberResponse>\n  \n  @Delete(':memberId')\n  @RequiredPermissions('project:members:delete')\n  removeMember(@Param('projectId') projectId: string, @Param('memberId') memberId: string): Promise<MessageResponse>\n}\n```\n\n### 2. Service Layer\n```typescript\n@Injectable()\nexport class ProjectsService {\n  constructor(\n    @InjectRepository(Project) private projectRepo: Repository<Project>,\n    @InjectRepository(ProjectMember) private memberRepo: Repository<ProjectMember>,\n    private permissionService: PermissionService,\n    private gitlabService: GitlabService,\n    private cacheService: CacheService,\n    private activityLogger: ActivityLoggerService,\n  ) {}\n  \n  async createProject(createDto: CreateProjectDto, owner: User): Promise<Project> {\n    return this.projectRepo.manager.transaction(async (manager) => {\n      // 1. 创建项目记录\n      const project = manager.create(Project, {\n        ...createDto,\n        owner,\n        isActive: true,\n        reviewConfig: this.getDefaultReviewConfig(),\n      });\n      \n      await manager.save(project);\n      \n      // 2. 添加所有者为项目管理员\n      const ownerMember = manager.create(ProjectMember, {\n        project,\n        user: owner,\n        role: ProjectRole.OWNER,\n        addedBy: owner,\n      });\n      \n      await manager.save(ownerMember);\n      \n      // 3. 记录活动日志\n      await this.activityLogger.log({\n        action: 'project.created',\n        projectId: project.id,\n        userId: owner.id,\n        metadata: { projectName: project.name },\n      });\n      \n      return project;\n    });\n  }\n  \n  async getProjectsForUser(user: User, query: ProjectQueryDto): Promise<PaginatedResult<Project>> {\n    const queryBuilder = this.projectRepo\n      .createQueryBuilder('project')\n      .leftJoin('project.members', 'member')\n      .leftJoin('member.user', 'user')\n      .where('user.id = :userId', { userId: user.id });\n    \n    if (query.search) {\n      queryBuilder.andWhere(\n        '(project.name LIKE :search OR project.description LIKE :search)',\n        { search: `%${query.search}%` }\n      );\n    }\n    \n    if (query.status) {\n      queryBuilder.andWhere('project.isActive = :isActive', {\n        isActive: query.status === 'active'\n      });\n    }\n    \n    const [projects, total] = await queryBuilder\n      .orderBy('project.updatedAt', 'DESC')\n      .take(query.limit)\n      .skip((query.page - 1) * query.limit)\n      .getManyAndCount();\n    \n    return {\n      items: projects,\n      pagination: {\n        page: query.page,\n        limit: query.limit,\n        total,\n        totalPages: Math.ceil(total / query.limit),\n      },\n    };\n  }\n}\n\n@Injectable()\nexport class PermissionService {\n  private readonly permissions = new Map<string, Permission>();\n  \n  constructor() {\n    this.initializePermissions();\n  }\n  \n  async checkPermission(user: User, projectId: string, action: string): Promise<boolean> {\n    // 1. 获取用户在项目中的角色\n    const member = await this.getMemberRole(user.id, projectId);\n    if (!member) return false;\n    \n    // 2. 检查角色权限\n    const permission = this.permissions.get(action);\n    if (!permission) return false;\n    \n    return permission.roles.includes(member.role);\n  }\n  \n  private initializePermissions() {\n    // 定义权限映射\n    this.permissions.set('project:read', {\n      roles: [ProjectRole.OWNER, ProjectRole.ADMIN, ProjectRole.MEMBER, ProjectRole.VIEWER],\n    });\n    \n    this.permissions.set('project:update', {\n      roles: [ProjectRole.OWNER, ProjectRole.ADMIN],\n    });\n    \n    this.permissions.set('project:delete', {\n      roles: [ProjectRole.OWNER],\n    });\n    \n    this.permissions.set('project:members:create', {\n      roles: [ProjectRole.OWNER, ProjectRole.ADMIN],\n    });\n    \n    // ... 更多权限定义\n  }\n}\n```\n\n### 3. Data Models\n```typescript\n@Entity('projects')\nexport class Project {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n  \n  @Column()\n  name: string;\n  \n  @Column({ type: 'text', nullable: true })\n  description: string;\n  \n  @Column()\n  gitlabProjectId: string;\n  \n  @Column()\n  gitlabProjectUrl: string;\n  \n  @Column({ nullable: true })\n  defaultBranch: string;\n  \n  @Column({ default: true })\n  isActive: boolean;\n  \n  @Column({ type: 'json', nullable: true })\n  reviewConfig: ReviewConfig;\n  \n  @Column({ nullable: true })\n  webhookId: string;\n  \n  @Column({ nullable: true })\n  webhookSecret: string;\n  \n  // Relations\n  @ManyToOne(() => User, { nullable: false })\n  owner: User;\n  \n  @OneToMany(() => ProjectMember, member => member.project)\n  members: ProjectMember[];\n  \n  @OneToMany(() => Review, review => review.project)\n  reviews: Review[];\n  \n  @OneToMany(() => ProjectStatistics, stats => stats.project)\n  statistics: ProjectStatistics[];\n  \n  @CreateDateColumn()\n  createdAt: Date;\n  \n  @UpdateDateColumn()\n  updatedAt: Date;\n}\n\n@Entity('project_members')\nexport class ProjectMember {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n  \n  @ManyToOne(() => Project, project => project.members)\n  project: Project;\n  \n  @ManyToOne(() => User)\n  user: User;\n  \n  @Column({\n    type: 'enum',\n    enum: ProjectRole,\n  })\n  role: ProjectRole;\n  \n  @Column({ type: 'json', nullable: true })\n  permissions: string[];\n  \n  @ManyToOne(() => User)\n  addedBy: User;\n  \n  @CreateDateColumn()\n  addedAt: Date;\n}\n\nexport enum ProjectRole {\n  OWNER = 'owner',\n  ADMIN = 'admin',\n  MEMBER = 'member',\n  VIEWER = 'viewer',\n}\n\nexport interface ReviewConfig {\n  enableAutoReview: boolean;\n  reviewTriggers: ('merge_request' | 'push' | 'manual')[];\n  excludePatterns: string[];\n  aiConfig: {\n    provider: string;\n    model: string;\n    maxTokens: number;\n    temperature: number;\n  };\n  notifications: {\n    email: boolean;\n    webhook?: string;\n    slack?: string;\n  };\n}\n```\n\n## API Design\n\n### Request/Response DTOs\n```typescript\nexport class CreateProjectDto {\n  @ApiProperty()\n  @IsString()\n  @MinLength(3)\n  @MaxLength(100)\n  name: string;\n  \n  @ApiProperty({ required: false })\n  @IsOptional()\n  @IsString()\n  @MaxLength(500)\n  description?: string;\n  \n  @ApiProperty()\n  @IsString()\n  gitlabProjectId: string;\n  \n  @ApiProperty()\n  @IsUrl()\n  gitlabProjectUrl: string;\n  \n  @ApiProperty({ required: false })\n  @IsOptional()\n  @IsString()\n  defaultBranch?: string;\n}\n\nexport class ProjectQueryDto {\n  @ApiProperty({ required: false, default: 1 })\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  page: number = 1;\n  \n  @ApiProperty({ required: false, default: 20 })\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  @Max(100)\n  limit: number = 20;\n  \n  @ApiProperty({ required: false })\n  @IsOptional()\n  @IsString()\n  search?: string;\n  \n  @ApiProperty({ required: false, enum: ['active', 'archived'] })\n  @IsOptional()\n  @IsEnum(['active', 'archived'])\n  status?: 'active' | 'archived';\n  \n  @ApiProperty({ required: false })\n  @IsOptional()\n  @IsUUID()\n  ownerId?: string;\n}\n\nexport class ProjectResponse {\n  @ApiProperty()\n  id: string;\n  \n  @ApiProperty()\n  name: string;\n  \n  @ApiProperty()\n  description: string;\n  \n  @ApiProperty()\n  gitlabProjectId: string;\n  \n  @ApiProperty()\n  gitlabProjectUrl: string;\n  \n  @ApiProperty()\n  defaultBranch: string;\n  \n  @ApiProperty()\n  isActive: boolean;\n  \n  @ApiProperty()\n  reviewConfig: ReviewConfig;\n  \n  @ApiProperty()\n  owner: UserSummary;\n  \n  @ApiProperty()\n  memberCount: number;\n  \n  @ApiProperty()\n  createdAt: Date;\n  \n  @ApiProperty()\n  updatedAt: Date;\n}\n```\n\n## Security and Permissions\n\n### RBAC Implementation\n```typescript\n// 权限装饰器\nexport const RequiredPermissions = (...permissions: string[]) => SetMetadata('permissions', permissions);\n\n// 权限守卫\n@Injectable()\nexport class PermissionsGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private permissionService: PermissionService,\n  ) {}\n  \n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const requiredPermissions = this.reflector.getAllAndOverride<string[]>('permissions', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    \n    if (!requiredPermissions) {\n      return true;\n    }\n    \n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    const projectId = request.params.projectId || request.params.id;\n    \n    if (!projectId) {\n      return false;\n    }\n    \n    for (const permission of requiredPermissions) {\n      if (!(await this.permissionService.checkPermission(user, projectId, permission))) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n}\n\n// 项目访问守卫\n@Injectable()\nexport class ProjectAccessGuard implements CanActivate {\n  constructor(private projectsService: ProjectsService) {}\n  \n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    const projectId = request.params.projectId || request.params.id;\n    \n    if (!projectId) {\n      return false;\n    }\n    \n    const hasAccess = await this.projectsService.checkUserAccess(user.id, projectId);\n    if (!hasAccess) {\n      throw new ForbiddenException('No access to this project');\n    }\n    \n    return true;\n  }\n}\n```\n\n## Statistics and Analytics\n\n### Statistics Service\n```typescript\n@Injectable()\nexport class StatisticsService {\n  constructor(\n    @InjectRepository(ProjectStatistics) private statsRepo: Repository<ProjectStatistics>,\n    @InjectRepository(Review) private reviewRepo: Repository<Review>,\n    private cacheService: CacheService,\n  ) {}\n  \n  async getProjectStatistics(projectId: string, dateRange: DateRange): Promise<ProjectStatsResponse> {\n    const cacheKey = `stats:${projectId}:${dateRange.from}:${dateRange.to}`;\n    \n    // 尝试从缓存获取\n    const cached = await this.cacheService.get<ProjectStatsResponse>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    \n    // 计算统计数据\n    const stats = await this.calculateProjectStats(projectId, dateRange);\n    \n    // 缓存结果（15分钟）\n    await this.cacheService.set(cacheKey, stats, 900);\n    \n    return stats;\n  }\n  \n  private async calculateProjectStats(projectId: string, dateRange: DateRange): Promise<ProjectStatsResponse> {\n    const [\n      totalReviews,\n      successfulReviews,\n      failedReviews,\n      avgQualityScore,\n      issuesFound,\n      issuesResolved,\n    ] = await Promise.all([\n      this.reviewRepo.count({\n        where: {\n          projectId,\n          createdAt: Between(dateRange.from, dateRange.to),\n        },\n      }),\n      this.reviewRepo.count({\n        where: {\n          projectId,\n          status: ReviewStatus.COMPLETED,\n          createdAt: Between(dateRange.from, dateRange.to),\n        },\n      }),\n      this.reviewRepo.count({\n        where: {\n          projectId,\n          status: ReviewStatus.FAILED,\n          createdAt: Between(dateRange.from, dateRange.to),\n        },\n      }),\n      this.reviewRepo\n        .createQueryBuilder('review')\n        .select('AVG(review.qualityScore)', 'avg')\n        .where('review.projectId = :projectId', { projectId })\n        .andWhere('review.createdAt BETWEEN :from AND :to', dateRange)\n        .getRawOne()\n        .then(result => parseFloat(result?.avg || '0')),\n      // ... 其他统计查询\n    ]);\n    \n    return {\n      overview: {\n        totalReviews,\n        successfulReviews,\n        failedReviews,\n        successRate: totalReviews > 0 ? successfulReviews / totalReviews : 0,\n        avgQualityScore,\n        issuesFound,\n        issuesResolved,\n      },\n      trends: await this.getTrendData(projectId, dateRange),\n      memberContributions: await this.getMemberContributions(projectId, dateRange),\n    };\n  }\n}\n```\n\n## Caching Strategy\n\n### Cache Implementation\n```typescript\n@Injectable()\nexport class ProjectCacheService {\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}\n  \n  // 缓存项目基本信息\n  async cacheProject(project: Project, ttl = 1800): Promise<void> {\n    await this.cacheManager.set(`project:${project.id}`, project, { ttl });\n  }\n  \n  // 缓存项目成员列表\n  async cacheProjectMembers(projectId: string, members: ProjectMember[], ttl = 900): Promise<void> {\n    await this.cacheManager.set(`project:${projectId}:members`, members, { ttl });\n  }\n  \n  // 缓存项目配置\n  async cacheProjectConfig(projectId: string, config: ReviewConfig, ttl = 3600): Promise<void> {\n    await this.cacheManager.set(`project:${projectId}:config`, config, { ttl });\n  }\n  \n  // 缓存用户项目列表\n  async cacheUserProjects(userId: string, projects: Project[], ttl = 600): Promise<void> {\n    await this.cacheManager.set(`user:${userId}:projects`, projects, { ttl });\n  }\n  \n  // 清除相关缓存\n  async invalidateProjectCache(projectId: string): Promise<void> {\n    const patterns = [\n      `project:${projectId}`,\n      `project:${projectId}:*`,\n      `stats:${projectId}:*`,\n    ];\n    \n    for (const pattern of patterns) {\n      await this.cacheManager.del(pattern);\n    }\n  }\n}\n```\n\n## Error Handling\n\n### Custom Exceptions\n```typescript\nexport class ProjectNotFoundException extends NotFoundException {\n  constructor(projectId: string) {\n    super({\n      code: 'PROJECT_001',\n      message: 'Project not found',\n      details: `Project with ID ${projectId} does not exist or you don't have access`,\n    });\n  }\n}\n\nexport class InsufficientPermissionException extends ForbiddenException {\n  constructor(action: string) {\n    super({\n      code: 'PROJECT_002',\n      message: 'Insufficient permission',\n      details: `You don't have permission to perform action: ${action}`,\n    });\n  }\n}\n\nexport class ProjectMemberNotFoundException extends NotFoundException {\n  constructor(memberId: string) {\n    super({\n      code: 'PROJECT_003',\n      message: 'Project member not found',\n      details: `Member with ID ${memberId} not found in this project`,\n    });\n  }\n}\n\nexport class GitlabIntegrationException extends BadRequestException {\n  constructor(error: string) {\n    super({\n      code: 'PROJECT_004',\n      message: 'GitLab integration failed',\n      details: error,\n    });\n  }\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n```typescript\ndescribe('ProjectsService', () => {\n  let service: ProjectsService;\n  let repository: Repository<Project>;\n  let memberRepository: Repository<ProjectMember>;\n  \n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        ProjectsService,\n        {\n          provide: getRepositoryToken(Project),\n          useClass: Repository,\n        },\n        {\n          provide: getRepositoryToken(ProjectMember),\n          useClass: Repository,\n        },\n        // ... 其他依赖的mock\n      ],\n    }).compile();\n    \n    service = module.get<ProjectsService>(ProjectsService);\n    repository = module.get<Repository<Project>>(getRepositoryToken(Project));\n  });\n  \n  describe('createProject', () => {\n    it('应该成功创建项目', async () => {\n      // 测试项目创建逻辑\n    });\n    \n    it('应该在GitLab项目重复时抛出错误', async () => {\n      // 测试重复项目处理\n    });\n  });\n  \n  describe('getProjectsForUser', () => {\n    it('应该返回用户有权限的项目列表', async () => {\n      // 测试项目查询和权限过滤\n    });\n    \n    it('应该支持搜索和分页', async () => {\n      // 测试搜索和分页功能\n    });\n  });\n});\n```\n\n## Performance Optimization\n\n### Database Optimization\n```sql\n-- 项目表索引\nCREATE INDEX idx_projects_owner_id ON projects(owner_id);\nCREATE INDEX idx_projects_gitlab_project_id ON projects(gitlab_project_id);\nCREATE INDEX idx_projects_is_active ON projects(is_active);\nCREATE INDEX idx_projects_updated_at ON projects(updated_at);\n\n-- 项目成员表索引\nCREATE INDEX idx_project_members_project_id ON project_members(project_id);\nCREATE INDEX idx_project_members_user_id ON project_members(user_id);\nCREATE INDEX idx_project_members_role ON project_members(role);\n\n-- 复合索引\nCREATE INDEX idx_project_members_project_user ON project_members(project_id, user_id);\n```\n\n### Query Optimization\n```typescript\n// 优化的项目查询，减少N+1问题\nasync getProjectWithMembers(projectId: string): Promise<Project> {\n  return this.projectRepo\n    .createQueryBuilder('project')\n    .leftJoinAndSelect('project.owner', 'owner')\n    .leftJoinAndSelect('project.members', 'members')\n    .leftJoinAndSelect('members.user', 'memberUser')\n    .where('project.id = :projectId', { projectId })\n    .getOne();\n}\n\n// 批量预加载用户权限\nasync preloadUserPermissions(userId: string, projectIds: string[]): Promise<Map<string, ProjectRole>> {\n  const members = await this.memberRepo\n    .createQueryBuilder('member')\n    .select(['member.projectId', 'member.role'])\n    .where('member.userId = :userId', { userId })\n    .andWhere('member.projectId IN (:...projectIds)', { projectIds })\n    .getMany();\n  \n  return new Map(members.map(member => [member.projectId, member.role]));\n}\n```\n\n## Module Configuration\n```typescript\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([Project, ProjectMember, ProjectStatistics]),\n    CacheModule.register(),\n    BullModule.registerQueue({\n      name: 'project-sync',\n    }),\n  ],\n  controllers: [\n    ProjectsController,\n    ProjectMembersController,\n    ProjectConfigController,\n    ProjectStatisticsController,\n  ],\n  providers: [\n    ProjectsService,\n    ProjectMembersService,\n    ProjectConfigService,\n    StatisticsService,\n    PermissionService,\n    ProjectCacheService,\n    ActivityLoggerService,\n    {\n      provide: APP_GUARD,\n      useClass: PermissionsGuard,\n    },\n  ],\n  exports: [\n    ProjectsService,\n    ProjectMembersService,\n    PermissionService,\n  ],\n})\nexport class ProjectManagementModule {}\n```\n\n这个设计文档涵盖了项目管理API系统的核心架构、数据模型、权限控制、缓存策略和性能优化等关键方面，为后续的具体实现提供了完整的技术指导。",
  "fileStats": {
    "size": 20915,
    "lines": 820,
    "lastModified": "2025-09-24T18:07:00.474Z"
  },
  "comments": []
}